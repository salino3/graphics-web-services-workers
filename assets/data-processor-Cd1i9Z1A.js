(function(){"use strict";const p="PersonDataDB",i="persons";let d=!1;const m=()=>new Promise((t,r)=>{const e=indexedDB.open(p,1);e.onupgradeneeded=a=>{const o=a.target.result;o.objectStoreNames.contains(i)||o.createObjectStore(i,{keyPath:"id"})},e.onsuccess=a=>{const o=a.target.result;t(o)},e.onerror=a=>{console.error("Worker: IndexedDB error:",a.target.error),r(a.target.error)}}),f=async()=>{const t=await m();return new Promise((r,e)=>{const a=t.transaction([i],"readonly"),s=a.objectStore(i).getAll();s.onsuccess=()=>{r(s.result)},s.onerror=n=>{console.error("Worker: Error reading from IndexDB:",n.target.error),e(n.target.error)},a.oncomplete=()=>{t.close()}})},D=async t=>{const r=await m();return new Promise((e,a)=>{const o=r.transaction([i],"readwrite"),s=o.objectStore(i);o.oncomplete=()=>{console.log("Worker: All persons written to IndexDB."),r.close(),e()},o.onerror=n=>{console.error("Worker: Error writing to IndexDB:",n.target.error),r.close(),a(n.target.error)},t.forEach(n=>{s.put(n)})})},u=[{name:"United States",area:9.8,avg:2},{name:"China",area:9.6,avg:4},{name:"India",area:3.2,avg:8},{name:"Indonesia",area:1.9,avg:8},{name:"Pakistan",area:.8,avg:5},{name:"Brazil",area:8.5,avg:2},{name:"Nigeria",area:.9,avg:3},{name:"Bangladesh",area:.14,avg:9},{name:"Russia",area:17.1,avg:3},{name:"Mexico",area:2,avg:2},{name:"Japan",area:.37,avg:2},{name:"Philippines",area:.3,avg:5},{name:"Ethiopia",area:1.1,avg:10},{name:"Egypt",area:1,avg:3},{name:"Germany",area:.35,avg:2},{name:"France",area:.64,avg:2},{name:"United Kingdom",area:.24,avg:4},{name:"Italy",area:.3,avg:5},{name:"Canada",area:9.9,avg:6},{name:"Australia",area:7.6,avg:7}],b=t=>{console.log(`Worker: Generating ${t} raw person records...`);const r=[],e=2e4,a=7e4,o=["Teacher","Engineer","Doctor","Artist","Programmer","Chef","Student","Retired","Manager","Salesperson"];for(let s=0;s<t;s++){const n=u[Math.floor(Math.random()*u.length)],h=Math.floor(e+Math.random()*(a-e)),c=Math.floor(18+Math.random()*60),l=o[Math.floor(Math.random()*o.length)],g=Math.floor(Math.random()*n.avg);r.push({id:s+1,country:n.name,age:c,work:l,awi:h,pets:g})}return r},y=()=>new Promise((t,r)=>{const e=indexedDB.deleteDatabase(p);e.onsuccess=()=>{console.log("Worker: IndexDB deleted successfully."),t()},e.onerror=a=>{const o=a.target.error;console.error("Worker: Error deleting IndexDB:",o),r(o)},e.onblocked=()=>{console.warn("Worker: Deletion blocked. Close all connections to the database."),r(new Error("Database deletion blocked."))}});self.onmessage=async t=>{if(d){console.warn("Worker: Ignoring message as another operation is in progress.");return}if(d=!0,t.data.type==="loadData"){const r=t.data.dataType;try{let e;console.log("Worker: Checking IndexDB for raw data..."),e=await f(),e.length===0?(console.log("Worker: Data not found in IndexDB. Generating new data..."),e=b(1e6),await D(e),console.log(`Worker: Generated and saved ${e.length} records to IndexDB.`)):console.log(`Worker: Loaded ${e.length} records from IndexDB.`);const a=new Map;let o=0;e.forEach(c=>{const l=c.country;a.has(l)||a.set(l,{population:0,totalPets:0});const g=a.get(l);g.population++,g.totalPets+=c.pets,o+=c.pets});const s=[],n=[];Array.from(a.keys()).sort().forEach(c=>{const l=a.get(c);if(s.push(c),r==="population")n.push(l.population);else if(r==="pets")n.push(l.totalPets);else if(r==="petsPercentage"){const g=o>0?l.totalPets/o*100:0;n.push(parseFloat(g.toFixed(2)))}}),console.log(`Worker: Data processed. Aggregated into ${s.length} unique countries. Sending results back.`),self.postMessage({type:"dataReady",labels:s,values:n,originalRecordCount:e.length,dataType:r})}catch(e){console.error("Worker: Error processing data:",e),self.postMessage({type:"error",message:e.message})}}else if(t.data.type==="clearData"){console.log("Worker: Clearing IndexDB and in-memory cache...");try{await y(),self.postMessage({type:"dataCleared"})}catch(r){console.error("Worker: Error during clear process:",r),self.postMessage({type:"error",message:`Error during clear process: ${r.message}`})}}d=!1}})();
